<html>
    <head>
        <meta charset="UTF-8" />
        <title>Document</title>
        <style>
        *{
            margin: 0;
            padding:0;
        }
        ul {
            /*font-size: 0;*/
            display: table;
        }
        ul>li{
            font-size: 16px;
            display: inline-block;
            padding: 20px;
            border: 1px solid #eee;
        }
        </style>
    </head>
    <body style="font-size: 20px;">
        <script>
            const config = {
                price: 20,
                total: 10000,
                active: 10000,
                step: 5
            }

        </script>

      <!--   <ul>
            <li>1</li>
            <li>2</li>
            <li>3</li>
        </ul> -->

        <!-- <input type="text" id="test"  /> -->

       <!--  <div style="background-color: red;position: relative;bottom: -20px;width: 100px;height: 100px;">1111</div>
        <div style="background-color: #000;z-index: 2;width: 120px;height: 100px;position: relative;">222222222</div> -->
        <!-- <div style="background-color: #000;z-index: 2;width: 120px;height: 100px;">222222222</div> -->
       <!--  <div class="test" style="font-size:  width: 200px;border: 1px solid #eee;">
            11111111
        </div>

        <div class="test" style="width: 10em;border: 1px solid #eee;">
            22222222
        </div>

        <div style="padding: 20px;border: 1px solid red;margin: 20px;width: 50px;height: 50px;">11111111111111</div>
        <div style="padding: 20px;border: 1px solid blue;margin: 20px;width: 50px;height: 50px;">222222222222222</div>

        <div style="padding:20px;border: 1px solid #ccc;width: 300px;">
            <div style="float: left;height: 80px;width: 200px;border: 1px solid red;">
                float子元素
            </div>
        </div> -->

        <div style="padding:20px;border: 1px solid #ccc;width: 300px;float: right;">
            测试Body是一个BFC吗
        </div>


        <script>

            // var foo = 1
            // function foo() {
            //     console.log(foo)
            // }
            // function foo() {
            //     console.log(22222)
            // }
            // console.log(bar)
            // console.log(foo)
            // foo()

              // var name = 'name1'
              // var type = 'type1'

              // function foo() {
              //   var name = 'name3'
              //   console.log(name)
              //   console.log(type)
              // }

              // function bar() {
              //   var name = 'name2'
              //   var type = 'type2'

              //   foo()
              // }

              // bar()

            var testobj = {
                a:'1',
                b:'2'
            }

            console.log(testobj)
            testobj.c = '3'
            testobj.a = 'a'
            console.log(testobj)

           // console.log()
           // console.log([1,2,3,4].splice(2))


           /** function f() {
                console.log( this.name );
            }
            var obj = {
                name: "Messi",
                f: f
            }

            obj.f()

            f()

            let test = obj.f
            test()


            let testObj = {
                name:'zhuzhu',
                fn:function() {
                    console.log(this.name)
                }
            }

            testObj.fn()*/
         
        function debounce(fn,delay) {
            let timer = null
            return function() {
                if(timer){
                    clearTimeout(timer)
                }
                timer = setTimeout(()=>{
                    fn.apply(this,arguments)
                    timer = null
                },delay)
            }
        }

        function throtte(fn,delay) {
            let canRun = true
            return function() {
                if(!canRun) return
                canRun = false
               setTimeout(()=>{
                    canRun = true
                    fn.apply(this,arguments)
                },delay)
            }
        }
       




        

                // console.log(a) 
                // if(true) {
                //     var a = 1
                // }
            


   // function runStack (n) { 
   //      if (n === 0) return 100; 
   //      return runStack( n- 2);
   //  }


    // function runStack(n) {
    //     while(n){
    //         n = n -2
    //     }

    //     return 100
    // }

    // runStack(50000)

    // // let n = 50000
    // // let b = 100
    // // while(n){
    // //     n = n -2
    // // }
    // // console.log()


// 螺旋遍历二维数组


let arr = [
    [1,2,3,4,5],
    [6,7,8,9,10],
    [11,12,13,14,15],
    [16,17,18,19,20],
    [21,22,23,24,25],
    [26,27,28,29,30]
]


// bar = {
//     myName:"time.geekbang.com",
//     printName: function () {
//         console.log(myName)
//     }
// }

// myname = "极客邦"
// _printName =  bar.printName


    // 等价于

    // function showName() {
    //     console.log(1)
    // }
    // var showName 


    // console.log(showName)
    // showName()
    // showName = function() {
    //     console.log(2)
    // }
    // console.log(showName)
    // showName()


    // 等价于下面的
    // function showName() {
    //     console.log('函数showName被执行');
    // }
    // var myname

    // showName()
    // console.log(myname)
    // myname = '极客时间'

    //
            // function add(){
            //     var a = 1
            //     return function(){
            //         console.log(a)
            //         alert(a++)
            //         // console.log(a)
            //     }
            // }
            // var f = add()

            // f()
            // f()

            // console.log(document.getElementsByClassName('test'))

    // let test = [{
    //     num:[1,2,3,4]
    // },{
    //     num:[2,3,5,2]
    // }]

    // test.map((item,idx)=>{
    //     let amount = item.num.reduce((pre,cur,index)=>{
    //         return index === 0?0:pre+cur
    //     },0)

    //     console.log(amount)
    // })


        /**
         * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。

         */
        

         // function isHuiWen(num) {
         //    if(!num) return
         //    let str = num+''
         //    let newStr = str.split('').reverse().join('')
         //    if(newStr == str){
         //        return true
         //    }

         //    return false
         // }

         function isHuiWen(num) {
            if(!num) return
            let str = num+''
            let len = str.length
            let i = 0

            while(i<len/2){
                if(str[i] != str[len-i-1]){
                    return false
                }
                i++
            }

            return true
         }



         // 闭包

























            

            // let el = document.getElementById('testTable')

            // console.log(el.style.width)
            // console.log(el.offsetWidth)
            // console.log(el.width)

            // let parentNode = el.parentNode
            // let next = el.nextSibling

            // let newNode = document.createElement('DIV')
            // newNode.appendChild(el)
            // parentNode.insertBefore(newNode,next)
            // parentNode.removeChild(el)

            // function testClick0() {
            //     console.log('000000')
            // }
            // function testClick(){
            //     console.log(11111)
            // }
            // function testClick1(){
            //     console.log(2222)
            // }

            // let obj = {
            //     foo:'1',
            //     bar:'2'
            // }

            // console.log(obj)

            // // Object.assign(obj.prototype, {
            // Object.assign(obj, {
            //   toString(){},
            //   toValue(){}
            // });
            //
            //  function Point(x, y) {
            //   this.x = x;
            //   this.y = y;
            //   return {
            //     x,
            //     y
            //   }
            // }

            // Point.prototype.toString = function () {
            //   return '(' + this.x + ', ' + this.y + ')';
            // // };

            // var p = new Point(1, 2);

            // console.log(Point.prototype)
            // console.log(p)

            // console.log(p.__proto__ == Point.prototype)

            // console.log(p.toString())

            // var minDepth = function(node,count) {
            //     count = count || 0
            //     if(!node) return count
            //     if(!node.left && !node.right) return count+1

            //     count++
            //     if(node.left && node.right){
            //         let left = minDepth(node.left,count)
            //         let right = minDepth(node.right,count)
            //          return left<right?left:right
            //     } else if(node.left){
            //         return minDepth(node.left,count)
            //     } else {
            //         return minDepth(node.right,count)
            //     }
            // };

            /**
             * 数组nums 求动态和
             *  【1，2，3，4】
             *  【1，3，6，10】
             */


            // let obj = new Object({
            //  foo:1,
            //  bar:2
            // })

            // console.log(obj)

            /**
             * 排列组合
             * @type {Number}
             */
            // let inputNum = 4
            // let index = 2

            // let numArr = []
            // for(let i = 1;i<=inputNum;i++){
            //     numArr.push(i)
            // }

            // let allNumArr = []

            // for(let i = 1;i<= inputNum;i++){
            //     getTranverse(numArr,i)
            // }

            // function getTranverse(arr, activeNum, str){
            //     arr = JSON.parse(JSON.stringify(arr))
            //     str = str || activeNum+''

            //     if(allNumArr.length >= index) return

            //     let idx = arr.findIndex(o=>{
            //         return o === activeNum
            //     })

            //     if(idx > -1){
            //         arr.splice(idx,1)
            //     }
            //     for(let j = 0;j<arr.length;j++){
            //         let tempStr = str + arr[j]
            //         if(tempStr.length == inputNum){
            //             allNumArr.push(parseInt(tempStr))
            //         } else {
            //             getTranverse(arr,arr[j],tempStr)
            //         }
            //     }
            // }

            // console.log(allNumArr)
            // if(allNumArr.length >= index){
            //     console.log(allNumArr[index-1])
            // } else {
            //     console.log(-1)
            // }

            /**
             * 链表倒叙
             */

            //  let node = {
            //     val:1,
            //     next:{
            //         val:2,
            //         next:{
            //             val:3,
            //             next:{
            //                 val:4,
            //                 next:{
            //                     val:5,
            //                     next:null
            //                 }
            //             }
            //         }
            //     }
            //  }

            //  function getReverseLink(head){
            //     if(head == null) return null

            //     let list = head
            //     let p = list
            //     let q = null
            //     while(p.next){
            //         q = p.next
            //         p.next = q.next
            //         q.next = list
            //         list = q
            //     }

            //     return null
            // }

            // console.log(getReverseLink(node))

            //双指针
            // function reverseNode(head){
            //     if(!head || !head.next) return head
            //     let cur = null
            //     let pre = head

            //     while(pre.next){
            //         // 保存pre的next
            //         let forSaveNextNode = pre.next
            //         // 修改pre的指针
            //         pre.next = cur
            //         // 双指针后移
            //         cur = pre
            //         pre = forSaveNextNode
            //     }

            //     return cur
            // }

            // // 递归
            // function reverseNode(head){
            //     if(!head || !head.next) return head
            //     let cur = null
            //     let pre = head

            //     while(pre.next){
            //         // 保存pre的next
            //         let forSaveNextNode = pre.next
            //         // 修改pre的指针
            //         pre.next = cur
            //         // 双指针后移
            //         cur = pre
            //         pre = forSaveNextNode
            //     }

            //     return cur
            // }
        </script>
    </body>
</html>
